<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Engine - Standalone Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        #container {
            display: flex;
            height: 100vh;
        }

        #sidebar {
            width: 300px;
            background: #2a2a2a;
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #00d4ff;
        }

        #canvas-container {
            flex: 1;
            position: relative;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        h1 {
            font-size: 18px;
            margin-bottom: 20px;
            color: #00d4ff;
            border-bottom: 2px solid #00d4ff;
            padding-bottom: 10px;
        }

        h2 {
            font-size: 14px;
            margin: 15px 0 8px 0;
            color: #00ff88;
        }

        .test-button {
            display: block;
            width: 100%;
            padding: 10px;
            margin: 6px 0;
            background: #3a3a3a;
            border: 2px solid #4a4a4a;
            color: #e0e0e0;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.3s;
        }

        .test-button:hover {
            background: #4a4a4a;
            border-color: #00d4ff;
        }

        .test-button.active {
            background: #00d4ff;
            color: #1a1a1a;
            border-color: #00d4ff;
        }

        .test-button.success {
            background: #00ff88;
            color: #1a1a1a;
            border-color: #00ff88;
        }

        .test-button.error {
            background: #ff4444;
            color: white;
            border-color: #ff4444;
        }

        #status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 20px;
            border-radius: 8px;
            border: 2px solid #00d4ff;
            font-size: 14px;
            max-width: 350px;
            z-index: 1000;
            display: none;
        }

        #status.show {
            display: block;
        }

        #status.success {
            border-color: #00ff88;
        }

        #status.error {
            border-color: #ff4444;
        }

        #stats {
            position: fixed;
            bottom: 20px;
            left: 320px;
            background: rgba(0, 0, 0, 0.9);
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 11px;
            font-family: monospace;
            border: 1px solid #00d4ff;
        }

        .info {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 12px;
            line-height: 1.6;
            border-left: 3px solid #00d4ff;
        }

        .info-title {
            color: #00d4ff;
            font-weight: bold;
            margin-bottom: 8px;
        }

        #run-all {
            background: #00ff88;
            color: #1a1a1a;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: bold;
            margin-left: 5px;
        }

        .badge.procedural { background: #00ff88; color: #000; }
        .badge.glsl { background: #00a8ff; color: #000; }
    </style>
</head>
<body>
    <div id="container">
        <div id="sidebar">
            <h1>ðŸ§ª Physics Engine Tests</h1>
            
            <div class="info">
                <div class="info-title">âœ¨ Standalone Version</div>
                Just open this file in your browser!<br>
                No server or npm needed.<br><br>
                <strong>Using Three.js from CDN</strong>
            </div>

            <button id="run-all" class="test-button">â–¶ Run All Tests</button>

            <h2>ðŸ“¦ Model Tests</h2>
            <button class="test-button" data-test="banked-track">
                Banked Track <span class="badge procedural">3D</span>
            </button>
            <button class="test-button" data-test="electric-plates">
                Electric Plates <span class="badge procedural">3D</span>
            </button>
            <button class="test-button" data-test="gold-foil">
                Gold Foil Setup <span class="badge procedural">3D</span>
            </button>
            <button class="test-button" data-test="double-slit">
                Double Slit <span class="badge procedural">3D</span>
            </button>
            <button class="test-button" data-test="pendulum">
                Pendulum Rig <span class="badge procedural">3D</span>
            </button>

            <h2>ðŸŽ¨ Shader Tests</h2>
            <button class="test-button" data-test="wave-shader">
                Wave Surface <span class="badge glsl">GLSL</span>
            </button>
            <button class="test-button" data-test="particle-system">
                Particle System <span class="badge glsl">JS</span>
            </button>
            <button class="test-button" data-test="heatmap">
                Heatmap <span class="badge glsl">JS</span>
            </button>

            <h2>ðŸ”¬ Integration</h2>
            <button class="test-button" data-test="all-models">
                All Models Together
            </button>
            <button class="test-button" data-test="lighting">
                Lighting Test
            </button>
        </div>

        <div id="canvas-container"></div>
    </div>

    <div id="status"></div>

    <div id="stats">
        <div>FPS: <span id="fps">0</span></div>
        <div>Objects: <span id="objects">0</span></div>
    </div>

    <!-- Three.js from CDN -->
    <script async src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script async src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Wait for Three.js to load
        function waitForThree() {
            return new Promise((resolve) => {
                const check = () => {
                    if (typeof THREE !== 'undefined' && THREE.OrbitControls) {
                        resolve();
                    } else {
                        setTimeout(check, 100);
                    }
                };
                check();
            });
        }

        waitForThree().then(() => {
            console.log('Three.js loaded!');
            
            class PhysicsTestSuite {
                constructor() {
                    this.scene = null;
                    this.camera = null;
                    this.renderer = null;
                    this.controls = null;
                    this.animationId = null;
                    this.fps = 0;
                    this.lastTime = performance.now();
                    this.frames = 0;

                    this.init();
                    this.setupEventListeners();
                }

                init() {
                    // Scene
                    this.scene = new THREE.Scene();
                    this.scene.background = new THREE.Color(0x0a0a0a);

                    // Camera
                    const container = document.getElementById('canvas-container');
                    this.camera = new THREE.PerspectiveCamera(
                        60,
                        container.clientWidth / container.clientHeight,
                        0.1,
                        1000
                    );
                    this.camera.position.set(20, 15, 20);

                    // Renderer
                    this.renderer = new THREE.WebGLRenderer({ antialias: true });
                    this.renderer.setSize(container.clientWidth, container.clientHeight);
                    this.renderer.setPixelRatio(window.devicePixelRatio);
                    container.appendChild(this.renderer.domElement);

                    // Controls
                    this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                    this.controls.enableDamping = true;
                    this.controls.autoRotate = true;
                    this.controls.autoRotateSpeed = 2;

                    // Lighting
                    const ambient = new THREE.AmbientLight(0xffffff, 0.4);
                    this.scene.add(ambient);

                    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    dirLight.position.set(20, 30, 10);
                    this.scene.add(dirLight);

                    const pointLight1 = new THREE.PointLight(0x00ff88, 0.5, 50);
                    pointLight1.position.set(-10, 10, -10);
                    this.scene.add(pointLight1);

                    const pointLight2 = new THREE.PointLight(0xff6b00, 0.5, 50);
                    pointLight2.position.set(10, 10, 10);
                    this.scene.add(pointLight2);

                    // Grid
                    const gridHelper = new THREE.GridHelper(50, 50, 0x00d4ff, 0x333333);
                    this.scene.add(gridHelper);

                    // Resize
                    window.addEventListener('resize', () => this.onWindowResize());

                    // Animate
                    this.animate();

                    this.showStatus('Test suite ready! Click any test to begin.', 'success');
                }

                setupEventListeners() {
                    document.querySelectorAll('.test-button[data-test]').forEach(button => {
                        button.addEventListener('click', () => {
                            this.runTest(button.dataset.test, button);
                        });
                    });

                    document.getElementById('run-all').addEventListener('click', () => {
                        this.runAllTests();
                    });
                }

                clearScene() {
                    const objectsToRemove = [];
                    this.scene.traverse((object) => {
                        if (object !== this.scene && 
                            !(object instanceof THREE.GridHelper) && 
                            !(object instanceof THREE.Light)) {
                            objectsToRemove.push(object);
                        }
                    });

                    objectsToRemove.forEach(object => {
                        if (object.parent) object.parent.remove(object);
                        if (object.geometry) object.geometry.dispose();
                        if (object.material) {
                            if (Array.isArray(object.material)) {
                                object.material.forEach(m => m.dispose());
                            } else {
                                object.material.dispose();
                            }
                        }
                    });
                }

                async runTest(testName, button) {
                    this.clearScene();
                    
                    document.querySelectorAll('.test-button[data-test]').forEach(btn => {
                        btn.classList.remove('active', 'success', 'error');
                    });
                    button.classList.add('active');

                    this.showStatus(`Running: ${testName}...`, 'info');

                    try {
                        await this.tests[testName].call(this);
                        button.classList.remove('active');
                        button.classList.add('success');
                        this.showStatus(`âœ“ Passed: ${testName}`, 'success');
                    } catch (error) {
                        button.classList.remove('active');
                        button.classList.add('error');
                        this.showStatus(`âœ— Failed: ${testName}`, 'error');
                        console.error('Test error:', error);
                    }
                }

                async runAllTests() {
                    const testButtons = Array.from(document.querySelectorAll('.test-button[data-test]'));
                    
                    for (const button of testButtons) {
                        await this.runTest(button.dataset.test, button);
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }

                    this.showStatus('All tests completed!', 'success');
                }

                // TEST IMPLEMENTATIONS
                tests = {
                    'banked-track': async function() {
                        const track = this.createBankedTrack(15, 5, 0.5, 64);
                        this.scene.add(track);
                        this.camera.position.set(25, 20, 25);
                    },

                    'electric-plates': async function() {
                        const plates = this.createElectricPlates();
                        this.scene.add(plates);
                        this.camera.position.set(8, 6, 8);
                    },

                    'gold-foil': async function() {
                        const setup = this.createGoldFoilSetup();
                        this.scene.add(setup);
                        this.camera.position.set(6, 4, 6);
                    },

                    'double-slit': async function() {
                        const barrier = this.createDoubleSlitBarrier();
                        this.scene.add(barrier);
                        this.camera.position.set(0, 5, 10);
                    },

                    'pendulum': async function() {
                        const pendulum = this.createPendulumRig();
                        this.scene.add(pendulum);
                        
                        // Animate
                        let angle = 0;
                        const animate = () => {
                            angle += 0.02;
                            const bob = pendulum.getObjectByName('bob');
                            if (bob) {
                                const length = 5;
                                const swing = 0.3 * Math.sin(angle);
                                bob.position.x = length * Math.sin(swing);
                                bob.position.y = -length * Math.cos(swing);
                            }
                            setTimeout(() => requestAnimationFrame(animate), 50);
                        };
                        animate();
                        
                        this.camera.position.set(10, 5, 10);
                    },

                    'wave-shader': async function() {
                        const geometry = new THREE.PlaneGeometry(20, 20, 64, 64);
                        const material = new THREE.ShaderMaterial({
                            uniforms: {
                                time: { value: 0 }
                            },
                            vertexShader: `
                                uniform float time;
                                varying float vHeight;
                                void main() {
                                    vec3 pos = position;
                                    float wave = sin(pos.x * 0.5 + time) * cos(pos.y * 0.5 + time);
                                    pos.z = wave * 0.5;
                                    vHeight = wave;
                                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                                }
                            `,
                            fragmentShader: `
                                varying float vHeight;
                                void main() {
                                    vec3 color = mix(vec3(0.0, 0.2, 1.0), vec3(1.0, 0.4, 0.0), vHeight * 0.5 + 0.5);
                                    gl_FragColor = vec4(color, 1.0);
                                }
                            `,
                            side: THREE.DoubleSide
                        });

                        const wave = new THREE.Mesh(geometry, material);
                        wave.rotation.x = -Math.PI / 2;
                        this.scene.add(wave);

                        const startTime = Date.now();
                        const animate = () => {
                            material.uniforms.time.value = (Date.now() - startTime) / 1000;
                            requestAnimationFrame(animate);
                        };
                        animate();

                        this.camera.position.set(0, 15, 15);
                    },

                    'particle-system': async function() {
                        const particles = [];
                        const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                        const particleMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff88 });

                        for (let i = 0; i < 100; i++) {
                            const particle = {
                                mesh: new THREE.Mesh(particleGeometry, particleMaterial),
                                velocity: new THREE.Vector3(
                                    Math.random() * 0.2 - 0.1,
                                    Math.random() * 0.2 - 0.1,
                                    Math.random() * 0.2 - 0.1
                                ),
                                position: new THREE.Vector3(
                                    Math.random() * 20 - 10,
                                    Math.random() * 20 - 10,
                                    Math.random() * 20 - 10
                                )
                            };
                            particle.mesh.position.copy(particle.position);
                            this.scene.add(particle.mesh);
                            particles.push(particle);
                        }

                        const animate = () => {
                            particles.forEach(p => {
                                p.position.add(p.velocity);
                                if (Math.abs(p.position.x) > 10) p.velocity.x *= -1;
                                if (Math.abs(p.position.y) > 10) p.velocity.y *= -1;
                                if (Math.abs(p.position.z) > 10) p.velocity.z *= -1;
                                p.mesh.position.copy(p.position);
                            });
                            requestAnimationFrame(animate);
                        };
                        animate();

                        this.camera.position.set(20, 15, 20);
                    },

                    'heatmap': async function() {
                        const size = 32;
                        const data = new Uint8Array(size * size * 4);

                        for (let i = 0; i < size; i++) {
                            for (let j = 0; j < size; j++) {
                                const x = (i / size - 0.5) * 2;
                                const y = (j / size - 0.5) * 2;
                                const dist = Math.sqrt(x * x + y * y);
                                const value = Math.exp(-dist * 2);

                                const idx = (i * size + j) * 4;
                                data[idx] = value * 255;
                                data[idx + 1] = (1 - value) * 255;
                                data[idx + 2] = 128;
                                data[idx + 3] = 255;
                            }
                        }

                        const texture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
                        texture.needsUpdate = true;

                        const geometry = new THREE.PlaneGeometry(10, 10);
                        const material = new THREE.MeshBasicMaterial({ map: texture });
                        const plane = new THREE.Mesh(geometry, material);
                        this.scene.add(plane);

                        this.camera.position.set(0, 0, 15);
                    },

                    'all-models': async function() {
                        const track = this.createBankedTrack(8, 3, 0.5, 32);
                        track.position.set(-12, 0, -12);
                        track.scale.set(0.5, 0.5, 0.5);
                        this.scene.add(track);

                        const plates = this.createElectricPlates();
                        plates.position.set(12, 0, -12);
                        plates.scale.set(0.7, 0.7, 0.7);
                        this.scene.add(plates);

                        const goldFoil = this.createGoldFoilSetup();
                        goldFoil.position.set(-12, 0, 12);
                        goldFoil.scale.set(1.2, 1.2, 1.2);
                        this.scene.add(goldFoil);

                        const doubleSlit = this.createDoubleSlitBarrier();
                        doubleSlit.position.set(12, 0, 12);
                        doubleSlit.scale.set(0.8, 0.8, 0.8);
                        this.scene.add(doubleSlit);

                        this.camera.position.set(30, 25, 30);
                    },

                    'lighting': async function() {
                        const sphere = new THREE.SphereGeometry(2, 32, 32);
                        const material = new THREE.MeshStandardMaterial({
                            color: 0xffffff,
                            roughness: 0.5,
                            metalness: 0.5
                        });
                        const mesh = new THREE.Mesh(sphere, material);
                        this.scene.add(mesh);
                    }
                };

                // MODEL CREATORS
                createBankedTrack(radius, width, bankAngle, segments) {
                    const group = new THREE.Group();
                    const geometry = new THREE.BufferGeometry();
                    const vertices = [];
                    const indices = [];

                    for (let i = 0; i <= segments; i++) {
                        const theta = (i / segments) * Math.PI * 2;
                        const cos = Math.cos(theta);
                        const sin = Math.sin(theta);

                        const innerRadius = radius - width / 2;
                        const outerRadius = radius + width / 2;

                        vertices.push(
                            innerRadius * cos, -width / 2 * Math.sin(bankAngle), innerRadius * sin,
                            outerRadius * cos, width / 2 * Math.sin(bankAngle), outerRadius * sin
                        );
                    }

                    for (let i = 0; i < segments; i++) {
                        const base = i * 2;
                        indices.push(base, base + 1, base + 2);
                        indices.push(base + 1, base + 3, base + 2);
                    }

                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                    geometry.setIndex(indices);
                    geometry.computeVertexNormals();

                    const material = new THREE.MeshStandardMaterial({ color: 0x444444 });
                    const track = new THREE.Mesh(geometry, material);
                    group.add(track);

                    return group;
                }

                createElectricPlates() {
                    const group = new THREE.Group();
                    const plateGeometry = new THREE.BoxGeometry(5, 0.1, 5);
                    
                    const upperPlate = new THREE.Mesh(plateGeometry, 
                        new THREE.MeshStandardMaterial({ color: 0xff4444, emissive: 0xff4444, emissiveIntensity: 0.2 }));
                    upperPlate.position.y = 1;
                    group.add(upperPlate);

                    const lowerPlate = new THREE.Mesh(plateGeometry,
                        new THREE.MeshStandardMaterial({ color: 0x4444ff, emissive: 0x4444ff, emissiveIntensity: 0.2 }));
                    lowerPlate.position.y = -1;
                    group.add(lowerPlate);

                    return group;
                }

                createGoldFoilSetup() {
                    const group = new THREE.Group();
                    
                    const foilGeometry = new THREE.CylinderGeometry(1, 1, 0.01, 64);
                    const foil = new THREE.Mesh(foilGeometry,
                        new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.9, roughness: 0.1 }));
                    foil.rotation.x = Math.PI / 2;
                    group.add(foil);

                    const detectorGeometry = new THREE.BoxGeometry(0.2, 0.4, 0.1);
                    const detectorMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00, transparent: true, opacity: 0.7 });

                    for (let i = 0; i < 9; i++) {
                        const angle = (i / 8) * Math.PI;
                        const detector = new THREE.Mesh(detectorGeometry, detectorMaterial);
                        detector.position.set(3 * Math.cos(angle), 0, 3 * Math.sin(angle));
                        detector.lookAt(0, 0, 0);
                        group.add(detector);
                    }

                    return group;
                }

                createDoubleSlitBarrier() {
                    const group = new THREE.Group();
                    
                    const barrier = new THREE.Mesh(
                        new THREE.BoxGeometry(4, 4, 0.1),
                        new THREE.MeshStandardMaterial({ color: 0x222222 })
                    );
                    group.add(barrier);

                    const screen = new THREE.Mesh(
                        new THREE.PlaneGeometry(4, 4),
                        new THREE.MeshStandardMaterial({ color: 0xffffff })
                    );
                    screen.position.z = 5;
                    group.add(screen);

                    return group;
                }

                createPendulumRig() {
                    const group = new THREE.Group();
                    
                    const base = new THREE.Mesh(
                        new THREE.CylinderGeometry(1, 1, 0.2, 32),
                        new THREE.MeshStandardMaterial({ color: 0x666666 })
                    );
                    base.position.y = -0.1;
                    group.add(base);

                    const column = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.05, 0.05, 5, 16),
                        new THREE.MeshStandardMaterial({ color: 0x888888 })
                    );
                    column.position.y = 2.5;
                    group.add(column);

                    const bob = new THREE.Mesh(
                        new THREE.SphereGeometry(0.3, 32, 32),
                        new THREE.MeshStandardMaterial({ color: 0xffaa00 })
                    );
                    bob.position.y = 0;
                    bob.name = 'bob';
                    group.add(bob);

                    return group;
                }

                animate() {
                    this.animationId = requestAnimationFrame(() => this.animate());
                    this.controls.update();
                    this.updateStats();
                    this.renderer.render(this.scene, this.camera);
                }

                updateStats() {
                    this.frames++;
                    const now = performance.now();
                    
                    if (now >= this.lastTime + 1000) {
                        this.fps = Math.round((this.frames * 1000) / (now - this.lastTime));
                        this.frames = 0;
                        this.lastTime = now;
                        document.getElementById('fps').textContent = this.fps;
                    }

                    let objectCount = 0;
                    this.scene.traverse((object) => {
                        if (object instanceof THREE.Mesh) objectCount++;
                    });
                    document.getElementById('objects').textContent = objectCount;
                }

                onWindowResize() {
                    const container = document.getElementById('canvas-container');
                    this.camera.aspect = container.clientWidth / container.clientHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(container.clientWidth, container.clientHeight);
                }

                showStatus(message, type = 'info') {
                    const status = document.getElementById('status');
                    status.textContent = message;
                    status.className = type + ' show';
                    setTimeout(() => status.classList.remove('show'), 3000);
                }
            }

            // Initialize
            const testSuite = new PhysicsTestSuite();
            console.log('Physics Test Suite Loaded!');
        });
    </script>
</body>
</html>